<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCHILLATOR - Academic Text Translator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    <style>
        .logo-font {
            font-family: 'Courier Prime', monospace;
            letter-spacing: 0.05em;
        }
        .copy-feedback {
            animation: fadeOut 2s forwards;
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
        .provider-tab {
            transition: all 0.2s;
        }
        .provider-tab.active {
            background-color: #2563eb;
            color: white;
        }
        .provider-tab:not(.active) {
            background-color: #e5e7eb;
            color: #374151;
        }
        .provider-tab:not(.active):hover {
            background-color: #d1d5db;
        }
        .mode-tab {
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        .mode-tab.active {
            border-bottom-color: #2563eb;
            color: #2563eb;
            font-weight: 600;
        }
        .mode-tab:not(.active):hover {
            background-color: #f3f4f6;
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
        .drop-zone {
            border: 2px dashed #d1d5db;
            transition: all 0.2s;
        }
        .drop-zone.dragover {
            border-color: #2563eb;
            background-color: #eff6ff;
        }
        .chunk-status {
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
        }
        /* History Modal */
        .history-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .history-modal.open {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .history-content {
            background: white;
            border-radius: 8px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .history-list {
            overflow-y: auto;
            flex: 1;
        }
        .history-item {
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
            transition: background 0.15s;
        }
        .history-item:hover {
            background: #f3f4f6;
        }
        .history-item-preview {
            font-size: 13px;
            color: #6b7280;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .history-item-meta {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-6">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-2xl font-bold text-gray-800 mb-1 logo-font">ARCHILLATOR</h1>
        <p class="text-gray-600 mb-4">Translate academic texts or fix spelling via Gemini, OpenAI, or Claude APIs. <a href="https://archilles.org" class="text-blue-600 hover:underline">Part of ARCHILLES</a></p>

        <!-- Mode Tabs -->
        <div class="flex border-b border-gray-300 mb-4">
            <button onclick="selectMode('passage')" id="mode-passage" 
                class="mode-tab active px-6 py-3 text-gray-600">
                üìù Passage
            </button>
            <button onclick="selectMode('document')" id="mode-document" 
                class="mode-tab px-6 py-3 text-gray-600">
                üìÑ Document
            </button>
            <button onclick="selectMode('proofread')" id="mode-proofread" 
                class="mode-tab px-6 py-3 text-gray-600">
                ‚úì Proofread
            </button>
        </div>

        <!-- Provider Selection -->
        <div class="bg-white rounded-lg shadow p-4 mb-4">
            <div class="flex flex-wrap items-center gap-4 mb-4">
                <span class="font-medium text-gray-700">Provider:</span>
                <div class="flex rounded-lg overflow-hidden border border-gray-300">
                    <button onclick="selectProvider('gemini')" id="tab-gemini" 
                        class="provider-tab active px-4 py-2 font-medium">
                        üî∑ Gemini
                    </button>
                    <button onclick="selectProvider('openai')" id="tab-openai" 
                        class="provider-tab px-4 py-2 font-medium">
                        üü¢ OpenAI
                    </button>
                    <button onclick="selectProvider('anthropic')" id="tab-anthropic" 
                        class="provider-tab px-4 py-2 font-medium">
                        üü† Claude
                    </button>
                </div>
            </div>

            <!-- Gemini Settings -->
            <div id="settings-gemini" class="flex flex-wrap gap-4 items-start">
                <div class="flex-1 min-w-[250px]">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Gemini API Key</label>
                    <input type="password" id="geminiApiKey" placeholder="AIza..." 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-xs text-blue-600 hover:underline">Get API key ‚Üí</a>
                </div>
                <div class="w-64">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Model</label>
                    <select id="geminiModel" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <optgroup label="Gemini 3 Series (latest)">
                            <option value="gemini-3-flash-preview">Gemini 3 Flash (fastest)</option>
                            <option value="gemini-3-pro-preview">Gemini 3 Pro (best quality)</option>
                        </optgroup>
                        <optgroup label="Gemini 2.5 Series (stable)">
                            <option value="gemini-2.5-flash">Gemini 2.5 Flash (fast, cheap)</option>
                            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                        </optgroup>
                    </select>
                </div>
            </div>

            <!-- OpenAI Settings -->
            <div id="settings-openai" class="flex flex-wrap gap-4 items-start hidden">
                <div class="flex-1 min-w-[250px]">
                    <label class="block text-sm font-medium text-gray-700 mb-1">OpenAI API Key</label>
                    <input type="password" id="openaiApiKey" placeholder="sk-..." 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500">
                    <a href="https://platform.openai.com/api-keys" target="_blank" class="text-xs text-green-600 hover:underline">Get API key ‚Üí</a>
                </div>
                <div class="w-64">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Model</label>
                    <select id="openaiModel" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500">
                        <optgroup label="GPT-5 Series (latest)">
                            <option value="gpt-5-mini">GPT-5 Mini (fast, efficient)</option>
                            <option value="gpt-5.1">GPT-5.1 (balanced)</option>
                            <option value="gpt-5.2">GPT-5.2 (best quality)</option>
                        </optgroup>
                        <optgroup label="GPT-4 Series">
                            <option value="gpt-4o-mini">GPT-4o Mini (fast, cheap)</option>
                            <option value="gpt-4o">GPT-4o</option>
                            <option value="gpt-4.1">GPT-4.1</option>
                        </optgroup>
                    </select>
                </div>
            </div>

            <!-- Anthropic/Claude Settings -->
            <div id="settings-anthropic" class="flex flex-wrap gap-4 items-start hidden">
                <div class="flex-1 min-w-[250px]">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Anthropic API Key</label>
                    <input type="password" id="anthropicApiKey" placeholder="sk-ant-..." 
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500">
                    <a href="https://console.anthropic.com/settings/keys" target="_blank" class="text-xs text-orange-600 hover:underline">Get API key ‚Üí</a>
                </div>
                <div class="w-64">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Model</label>
                    <select id="anthropicModel" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-orange-500">
                        <optgroup label="Claude 4.5 Series (latest)">
                            <option value="claude-haiku-4-5-20251001">Claude Haiku 4.5 (fast, cheap)</option>
                            <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5 (balanced)</option>
                            <option value="claude-opus-4-5-20251124">Claude Opus 4.5 (best quality)</option>
                        </optgroup>
                        <optgroup label="Claude 4 Series">
                            <option value="claude-sonnet-4-20250514">Claude Sonnet 4</option>
                            <option value="claude-opus-4-20250514">Claude Opus 4</option>
                        </optgroup>
                    </select>
                </div>
            </div>

            <!-- Common Settings -->
            <div class="flex flex-wrap gap-4 items-end mt-4 pt-4 border-t border-gray-200">
                <div class="w-40">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Translate to</label>
                    <select id="targetLang" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="de">German</option>
                        <option value="en">English</option>
                        <option value="fr">French</option>
                        <option value="es">Spanish</option>
                        <option value="it">Italian</option>
                        <option value="la">Latin</option>
                        <option value="el">Greek (modern)</option>
                        <option value="grc">Ancient Greek</option>
                    </select>
                </div>
                <div class="w-48">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Style</label>
                    <select id="styleHint" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="academic">Academic / scholarly</option>
                        <option value="neutral">Neutral / general</option>
                        <option value="simple">Simplified / readable</option>
                        <option value="literal">As literal as possible</option>
                    </select>
                </div>
                <div class="flex items-center gap-2 pb-2">
                    <input type="checkbox" id="blankLines" class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500">
                    <label for="blankLines" class="text-sm text-gray-700">Blank lines between paragraphs</label>
                </div>
            </div>
        </div>

        <!-- ==================== PASSAGE MODE ==================== -->
        <div id="panel-passage">
            <div class="grid md:grid-cols-2 gap-4">
                <!-- Input Panel -->
                <div class="bg-white rounded-lg shadow p-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="font-medium text-gray-700">Input (paste from PDF)</label>
                        <div class="flex gap-3">
                            <button onclick="openHistory('passage')" class="text-sm text-blue-600 hover:text-blue-800">üìã History</button>
                            <button onclick="clearPassageInput()" class="text-sm text-gray-500 hover:text-gray-700">Clear</button>
                        </div>
                    </div>
                    <textarea id="passageInput" rows="14" placeholder="Paste text from PDF here...

Note: Single line breaks will become spaces.
Use double line breaks (empty line) to preserve paragraphs."
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-sm"></textarea>
                    
                    <div class="flex gap-2 mt-3">
                        <button onclick="cleanPassage()" 
                            class="flex-1 bg-gray-600 text-white py-2 px-4 rounded-md hover:bg-gray-700 transition font-medium">
                            Clean only
                        </button>
                        <button onclick="translatePassage(false)" id="translatePassageBtn"
                            class="flex-1 bg-amber-600 text-white py-2 px-4 rounded-md hover:bg-amber-700 transition font-medium">
                            Translate only
                        </button>
                        <button onclick="translatePassage(true)" id="cleanTranslateBtn"
                            class="flex-1 bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition font-medium">
                            Clean & Translate
                        </button>
                    </div>
                </div>

                <!-- Output Panel -->
                <div class="bg-white rounded-lg shadow p-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="font-medium text-gray-700">Output</label>
                        <div class="flex items-center gap-2">
                            <span id="copyFeedback" class="text-green-600 text-sm hidden">Copied!</span>
                            <button onclick="copyPassageOutput()" class="text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded transition">
                                Copy
                            </button>
                        </div>
                    </div>
                    <textarea id="passageOutput" rows="14" readonly
                        class="w-full px-3 py-2 border border-gray-300 rounded-md bg-gray-50 font-mono text-sm"></textarea>
                    
                    <div id="passageStatus" class="mt-3 text-sm text-gray-500"></div>
                </div>
            </div>

            <!-- Info Box -->
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-4">
                <h3 class="font-medium text-blue-800 mb-2">How does the cleaning work?</h3>
                <p class="text-sm text-blue-700">
                    Single line breaks become spaces (flowing text). 
                    Two or more consecutive line breaks become a paragraph break.
                    Hyphens at line endings are joined (syllable hyphenation).
                </p>
            </div>
        </div>

        <!-- ==================== DOCUMENT MODE ==================== -->
        <div id="panel-document" class="hidden">
            <div class="bg-white rounded-lg shadow p-4 mb-4">
                <!-- File Upload -->
                <div id="dropZone" class="drop-zone rounded-lg p-8 text-center cursor-pointer"
                    onclick="document.getElementById('fileInput').click()">
                    <input type="file" id="fileInput" accept=".docx,.epub,.txt" class="hidden" onchange="handleFileSelect(event)">
                    <div class="text-4xl mb-2">üìÅ</div>
                    <p class="text-gray-600 font-medium">Drop file here or click to select</p>
                    <p class="text-gray-400 text-sm mt-1">Supported: DOCX, EPUB, TXT</p>
                </div>

                <!-- File Info -->
                <div id="fileInfo" class="hidden mt-4 p-4 bg-gray-50 rounded-lg">
                    <div class="flex justify-between items-start">
                        <div>
                            <p class="font-medium text-gray-800" id="fileName">filename.docx</p>
                            <p class="text-sm text-gray-500" id="fileStats">0 paragraphs ‚Ä¢ 0 characters</p>
                        </div>
                        <button onclick="clearDocument()" class="text-sm text-red-600 hover:text-red-800">Remove</button>
                    </div>
                    
                    <!-- Cost Estimate -->
                    <div id="costEstimate" class="mt-3 p-3 bg-amber-50 border border-amber-200 rounded text-sm">
                        <p class="font-medium text-amber-800">Estimated cost:</p>
                        <p class="text-amber-700" id="costText">Calculating...</p>
                    </div>
                </div>

                <!-- Progress -->
                <div id="progressSection" class="hidden mt-4">
                    <div class="flex justify-between text-sm text-gray-600 mb-1">
                        <span id="progressText">Translating...</span>
                        <span id="progressPercent">0%</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-3">
                        <div id="progressBar" class="progress-bar bg-blue-600 h-3 rounded-full" style="width: 0%"></div>
                    </div>
                    <div id="chunkStatus" class="chunk-status mt-2 p-2 bg-gray-100 rounded text-gray-600"></div>
                </div>

                <!-- Controls -->
                <div class="flex gap-3 mt-4">
                    <button onclick="startDocumentTranslation()" id="startTranslationBtn"
                        class="flex-1 bg-blue-600 text-white py-3 px-6 rounded-md hover:bg-blue-700 transition font-medium disabled:bg-gray-400 disabled:cursor-not-allowed"
                        disabled>
                        Start Translation
                    </button>
                    <button onclick="stopDocumentTranslation()" id="stopTranslationBtn"
                        class="bg-red-600 text-white py-3 px-6 rounded-md hover:bg-red-700 transition font-medium hidden">
                        Stop
                    </button>
                    <button onclick="downloadTranslation()" id="downloadBtn"
                        class="bg-green-600 text-white py-3 px-6 rounded-md hover:bg-green-700 transition font-medium hidden">
                        Download Translation
                    </button>
                </div>

                <!-- Resume Prompt -->
                <div id="resumePrompt" class="hidden mt-4 p-4 bg-yellow-50 border border-yellow-300 rounded-lg">
                    <p class="font-medium text-yellow-800">Unfinished translation found!</p>
                    <p class="text-sm text-yellow-700 mt-1" id="resumeInfo">File: example.docx ‚Ä¢ 45/120 paragraphs completed</p>
                    <p class="text-sm text-yellow-600 mt-1" id="resumeProviderInfo"></p>
                    <div class="flex gap-2 mt-3">
                        <button onclick="resumeTranslation()" class="bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700">
                            Resume with current provider
                        </button>
                        <button onclick="discardCheckpoint()" class="bg-gray-400 text-white px-4 py-2 rounded hover:bg-gray-500">
                            Discard & Start Fresh
                        </button>
                    </div>
                </div>
            </div>

            <!-- Info Box -->
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                <h3 class="font-medium text-blue-800 mb-2">Document Translation</h3>
                <p class="text-sm text-blue-700">
                    Upload a DOCX, EPUB, or TXT file. The text will be split into chunks and translated paragraph by paragraph.
                    Progress is saved automatically ‚Äì if the browser closes, you can resume later.
                    <br><br>
                    <strong>Output formats:</strong> EPUB ‚Üí EPUB (formatting preserved) ‚Ä¢ DOCX ‚Üí DOCX ‚Ä¢ TXT ‚Üí TXT
                    <br>
                    <strong>Tip:</strong> For PDFs, convert to EPUB first (e.g., using Calibre) for best results.
                </p>
            </div>
        </div>

        <!-- ==================== PROOFREAD MODE ==================== -->
        <div id="panel-proofread" class="hidden">
            <div class="grid md:grid-cols-2 gap-4">
                <!-- Input Panel -->
                <div class="bg-white rounded-lg shadow p-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="font-medium text-gray-700">Input text</label>
                        <div class="flex gap-3">
                            <button onclick="openHistory('proofread')" class="text-sm text-blue-600 hover:text-blue-800">üìã History</button>
                            <button onclick="clearProofreadInput()" class="text-sm text-gray-500 hover:text-gray-700">Clear</button>
                        </div>
                    </div>
                    <textarea id="proofreadInput" rows="14" placeholder="Paste text to proofread here...

Works great for:
‚Ä¢ OCR text with missing umlauts (a‚Üí√§, o‚Üí√∂, u‚Üí√º)
‚Ä¢ ALL CAPS text ‚Üí normal capitalization
‚Ä¢ Scanned documents with typos"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-sm"></textarea>
                    
                    <!-- Correction Level -->
                    <div class="mt-3 mb-3">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Correction level</label>
                        <div class="flex flex-wrap gap-2">
                            <label class="flex items-center gap-2 px-3 py-2 border rounded-md cursor-pointer hover:bg-gray-50">
                                <input type="radio" name="proofreadLevel" value="spelling" checked class="text-blue-600">
                                <span class="text-sm">Spelling only</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border rounded-md cursor-pointer hover:bg-gray-50">
                                <input type="radio" name="proofreadLevel" value="light" class="text-blue-600">
                                <span class="text-sm">+ Punctuation</span>
                            </label>
                            <label class="flex items-center gap-2 px-3 py-2 border rounded-md cursor-pointer hover:bg-gray-50">
                                <input type="radio" name="proofreadLevel" value="grammar" class="text-blue-600">
                                <span class="text-sm">+ Grammar</span>
                            </label>
                        </div>
                    </div>

                    <!-- Language Selection for Proofread -->
                    <div class="mb-3">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Text language</label>
                        <select id="proofreadLang" class="w-40 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="de">German</option>
                            <option value="en">English</option>
                            <option value="fr">French</option>
                            <option value="es">Spanish</option>
                            <option value="it">Italian</option>
                        </select>
                    </div>
                    
                    <button onclick="proofreadText()" id="proofreadBtn"
                        class="w-full bg-emerald-600 text-white py-2 px-4 rounded-md hover:bg-emerald-700 transition font-medium">
                        ‚úì Proofread
                    </button>
                </div>

                <!-- Output Panel -->
                <div class="bg-white rounded-lg shadow p-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="font-medium text-gray-700">Corrected text</label>
                        <div class="flex items-center gap-2">
                            <span id="proofreadCopyFeedback" class="text-green-600 text-sm hidden">Copied!</span>
                            <button onclick="copyProofreadOutput()" class="text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded transition">
                                Copy
                            </button>
                        </div>
                    </div>
                    <textarea id="proofreadOutput" rows="14" readonly
                        class="w-full px-3 py-2 border border-gray-300 rounded-md bg-gray-50 font-mono text-sm"></textarea>
                    
                    <div id="proofreadStatus" class="mt-3 text-sm text-gray-500"></div>
                </div>
            </div>

            <!-- Info Box -->
            <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mt-4">
                <h3 class="font-medium text-emerald-800 mb-2">Proofread Mode</h3>
                <p class="text-sm text-emerald-700">
                    <strong>Spelling only:</strong> Fixes typos, missing umlauts (√§, √∂, √º, √ü), and normalizes ALL CAPS to proper capitalization. No style changes.<br>
                    <strong>+ Punctuation:</strong> Also fixes commas, periods, quotation marks.<br>
                    <strong>+ Grammar:</strong> Also fixes grammatical errors, but still no rewording or style changes.
                </p>
            </div>
        </div>

        <!-- Cost Comparison -->
        <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mt-4">
            <h3 class="font-medium text-amber-800 mb-2">Cost comparison (approx. per 100,000 characters)</h3>
            <p class="text-sm text-amber-700">
                <strong>Gemini 3 Flash:</strong> ~$0.015 ‚Ä¢ 
                <strong>Gemini 2.5 Flash:</strong> ~$0.02 ‚Ä¢ 
                <strong>GPT-4o Mini:</strong> ~$0.02 ‚Ä¢ 
                <strong>Claude Haiku:</strong> ~$0.04 ‚Ä¢ 
                <strong>Claude Sonnet:</strong> ~$0.15 ‚Ä¢ 
                <strong>GPT-4o:</strong> ~$0.30 ‚Ä¢ 
                <strong>Claude Opus:</strong> ~$0.75
            </p>
        </div>

        <!-- Footer -->
        <div class="text-center text-gray-400 text-sm mt-6">
            Part of the <a href="https://archilles.org" class="text-blue-500 hover:underline">ARCHILLES</a> project
        </div>
    </div>

    <!-- History Modal -->
    <div id="historyModal" class="history-modal" onclick="closeHistoryModal(event)">
        <div class="history-content" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center p-4 border-b">
                <h3 class="font-semibold text-gray-800" id="historyTitle">Translation History</h3>
                <div class="flex gap-2">
                    <button onclick="clearHistory()" class="text-sm text-red-600 hover:text-red-800">Clear all</button>
                    <button onclick="closeHistoryModal()" class="text-gray-500 hover:text-gray-700 text-xl leading-none">&times;</button>
                </div>
            </div>
            <div class="history-list" id="historyList">
                <!-- Filled dynamically -->
            </div>
            <div class="p-3 border-t text-center text-xs text-gray-400" id="historyFooter">
                Click an entry to restore it
            </div>
        </div>
    </div>

    <script>
        // ==================== STATE ====================
        let currentProvider = 'gemini';
        let currentMode = 'passage';
        let documentParagraphs = [];
        let translatedParagraphs = [];
        let currentFileType = null;
        let currentFileName = null;
        let originalDocxZip = null;
        let originalEpubZip = null;
        let epubTextNodes = []; // Stores {filePath, nodeIndex, text} for EPUB reconstruction
        let isTranslating = false;
        let shouldStop = false;

        // ==================== INITIALIZATION ====================
        const geminiKeyInput = document.getElementById('geminiApiKey');
        const openaiKeyInput = document.getElementById('openaiApiKey');
        const anthropicKeyInput = document.getElementById('anthropicApiKey');
        
        // Load saved keys
        const savedGeminiKey = localStorage.getItem('geminiApiKey');
        const savedOpenaiKey = localStorage.getItem('openaiApiKey');
        const savedAnthropicKey = localStorage.getItem('anthropicApiKey');
        if (savedGeminiKey) geminiKeyInput.value = savedGeminiKey;
        if (savedOpenaiKey) openaiKeyInput.value = savedOpenaiKey;
        if (savedAnthropicKey) anthropicKeyInput.value = savedAnthropicKey;
        
        // Save keys on change
        geminiKeyInput.addEventListener('change', () => localStorage.setItem('geminiApiKey', geminiKeyInput.value));
        openaiKeyInput.addEventListener('change', () => localStorage.setItem('openaiApiKey', openaiKeyInput.value));
        anthropicKeyInput.addEventListener('change', () => localStorage.setItem('anthropicApiKey', anthropicKeyInput.value));

        // Drag and drop
        const dropZone = document.getElementById('dropZone');
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        });

        // Check for saved checkpoint on load
        checkForCheckpoint();

        // ==================== MODE & PROVIDER SELECTION ====================
        function selectMode(mode) {
            currentMode = mode;
            document.getElementById('mode-passage').classList.toggle('active', mode === 'passage');
            document.getElementById('mode-document').classList.toggle('active', mode === 'document');
            document.getElementById('mode-proofread').classList.toggle('active', mode === 'proofread');
            document.getElementById('panel-passage').classList.toggle('hidden', mode !== 'passage');
            document.getElementById('panel-document').classList.toggle('hidden', mode !== 'document');
            document.getElementById('panel-proofread').classList.toggle('hidden', mode !== 'proofread');
        }

        function selectProvider(provider) {
            currentProvider = provider;
            document.getElementById('tab-gemini').classList.toggle('active', provider === 'gemini');
            document.getElementById('tab-openai').classList.toggle('active', provider === 'openai');
            document.getElementById('tab-anthropic').classList.toggle('active', provider === 'anthropic');
            document.getElementById('settings-gemini').classList.toggle('hidden', provider !== 'gemini');
            document.getElementById('settings-openai').classList.toggle('hidden', provider !== 'openai');
            document.getElementById('settings-anthropic').classList.toggle('hidden', provider !== 'anthropic');
        }

        // ==================== PASSAGE MODE ====================
        function cleanPdfText(text) {
            if (!text.trim()) return '';
            
            let result = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            result = result.replace(/(\w)-\n(\w)/g, '$1$2');
            result = result.replace(/\n\s*\n[\n\s]*/g, '{{PARA}}');
            result = result.replace(/\n/g, ' ');
            result = result.replace(/  +/g, ' ');
            result = result.replace(/\{\{PARA\}\}/g, '\n\n');
            result = result.replace(/\n{3,}/g, '\n\n');
            result = result.replace(/\n /g, '\n');
            result = result.replace(/ \n/g, '\n');
            return result.trim();
        }

        function cleanPassage() {
            const input = document.getElementById('passageInput').value;
            const cleaned = cleanPdfText(input);
            document.getElementById('passageOutput').value = cleaned;
            document.getElementById('passageStatus').textContent = `Cleaned: ${input.length} ‚Üí ${cleaned.length} characters`;
        }

        function clearPassageInput() {
            document.getElementById('passageInput').value = '';
            document.getElementById('passageOutput').value = '';
            document.getElementById('passageStatus').textContent = '';
            document.getElementById('passageInput').focus();
        }

        function copyPassageOutput() {
            const output = document.getElementById('passageOutput');
            output.select();
            document.execCommand('copy');
            
            const feedback = document.getElementById('copyFeedback');
            feedback.classList.remove('hidden');
            feedback.classList.add('copy-feedback');
            setTimeout(() => {
                feedback.classList.add('hidden');
                feedback.classList.remove('copy-feedback');
            }, 2000);
        }

        async function translatePassage(shouldClean) {
            let apiKey;
            let providerName;
            
            if (currentProvider === 'gemini') {
                apiKey = geminiKeyInput.value.trim();
                providerName = 'Gemini';
            } else if (currentProvider === 'openai') {
                apiKey = openaiKeyInput.value.trim();
                providerName = 'OpenAI';
            } else {
                apiKey = anthropicKeyInput.value.trim();
                providerName = 'Claude';
            }
                
            if (!apiKey) {
                alert(`Please enter your ${providerName} API key!`);
                return;
            }

            let text = document.getElementById('passageInput').value;
            if (!text.trim()) {
                alert('Please enter some text!');
                return;
            }

            if (shouldClean) {
                text = cleanPdfText(text);
            }

            document.getElementById('passageOutput').value = 'Translating...';
            document.getElementById('passageStatus').textContent = `Sending to ${providerName}...`;

            const btn = shouldClean ? document.getElementById('cleanTranslateBtn') : document.getElementById('translatePassageBtn');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Translating...';

            try {
                const translated = await translateText(text, apiKey);
                document.getElementById('passageOutput').value = translated;
                document.getElementById('passageStatus').textContent = 
                    `Translated with ${currentProvider}: ${text.length} ‚Üí ${translated.length} characters`;
                
                // Save to history
                const targetLang = document.getElementById('targetLang').value;
                addToHistory('passage', text, translated, { targetLang });
            } catch (error) {
                document.getElementById('passageOutput').value = `Error: ${error.message}`;
                document.getElementById('passageStatus').textContent = 'Translation error';
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // ==================== PROOFREAD MODE ====================
        function clearProofreadInput() {
            document.getElementById('proofreadInput').value = '';
            document.getElementById('proofreadOutput').value = '';
            document.getElementById('proofreadStatus').textContent = '';
            document.getElementById('proofreadInput').focus();
        }

        function copyProofreadOutput() {
            const output = document.getElementById('proofreadOutput');
            output.select();
            document.execCommand('copy');
            
            const feedback = document.getElementById('proofreadCopyFeedback');
            feedback.classList.remove('hidden');
            feedback.classList.add('copy-feedback');
            setTimeout(() => {
                feedback.classList.add('hidden');
                feedback.classList.remove('copy-feedback');
            }, 2000);
        }

        function getProofreadPrompt(text) {
            const level = document.querySelector('input[name="proofreadLevel"]:checked').value;
            const lang = document.getElementById('proofreadLang').value;
            
            const langNames = {
                'de': 'German', 'en': 'English', 'fr': 'French', 'es': 'Spanish', 'it': 'Italian'
            };
            
            let instructions = '';
            
            if (level === 'spelling') {
                instructions = `Fix ONLY the following in this ${langNames[lang]} text:
- Spelling errors and typos
- Missing umlauts (a‚Üí√§, o‚Üí√∂, u‚Üí√º) and special characters (s‚Üí√ü for German)
- ALL CAPS text should be converted to normal capitalization

Do NOT change:
- Word choice or vocabulary
- Sentence structure
- Writing style
- Punctuation (unless clearly wrong like missing period at end)`;
            } else if (level === 'light') {
                instructions = `Fix ONLY the following in this ${langNames[lang]} text:
- Spelling errors and typos
- Missing umlauts and special characters
- ALL CAPS text ‚Üí normal capitalization
- Punctuation (commas, periods, quotation marks)

Do NOT change:
- Word choice or vocabulary
- Sentence structure
- Writing style`;
            } else {
                instructions = `Fix the following in this ${langNames[lang]} text:
- Spelling errors and typos
- Missing umlauts and special characters
- ALL CAPS text ‚Üí normal capitalization
- Punctuation
- Grammatical errors

Do NOT change:
- Word choice or vocabulary (unless grammatically required)
- Writing style
- Do not reword or rephrase sentences`;
            }

            return `${instructions}

Output ONLY the corrected text, nothing else. No explanations, no markup, no "Here is the corrected text:" - just the text itself.

Text to correct:
${text}`;
        }

        async function proofreadText() {
            let apiKey;
            let providerName;
            
            if (currentProvider === 'gemini') {
                apiKey = geminiKeyInput.value.trim();
                providerName = 'Gemini';
            } else if (currentProvider === 'openai') {
                apiKey = openaiKeyInput.value.trim();
                providerName = 'OpenAI';
            } else {
                apiKey = anthropicKeyInput.value.trim();
                providerName = 'Claude';
            }
                
            if (!apiKey) {
                alert(`Please enter your ${providerName} API key!`);
                return;
            }

            const text = document.getElementById('proofreadInput').value;
            if (!text.trim()) {
                alert('Please enter some text!');
                return;
            }

            document.getElementById('proofreadOutput').value = 'Proofreading...';
            document.getElementById('proofreadStatus').textContent = `Sending to ${providerName}...`;

            const btn = document.getElementById('proofreadBtn');
            btn.disabled = true;
            btn.textContent = 'Proofreading...';

            try {
                const prompt = getProofreadPrompt(text);
                const corrected = await sendProofreadRequest(prompt, apiKey);
                document.getElementById('proofreadOutput').value = corrected;
                document.getElementById('proofreadStatus').textContent = 
                    `Proofread with ${providerName}: ${text.length} characters`;
                
                // Save to history
                const textLang = document.getElementById('proofreadLang').value;
                const level = document.querySelector('input[name="proofreadLevel"]:checked').value;
                addToHistory('proofread', text, corrected, { textLang, level });
            } catch (error) {
                document.getElementById('proofreadOutput').value = `Error: ${error.message}`;
                document.getElementById('proofreadStatus').textContent = 'Proofreading error';
            } finally {
                btn.disabled = false;
                btn.textContent = '‚úì Proofread';
            }
        }

        async function sendProofreadRequest(prompt, apiKey) {
            if (currentProvider === 'gemini') {
                const model = document.getElementById('geminiModel').value;
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: { temperature: 0.1, maxOutputTokens: 8192 }
                        })
                    }
                );
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || `API Error: ${response.status}`);
                }
                const data = await response.json();
                if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    throw new Error('Empty response');
                }
                return data.candidates[0].content.parts[0].text.trim();
                
            } else if (currentProvider === 'openai') {
                const model = document.getElementById('openaiModel').value;
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.1,
                        max_tokens: 8192
                    })
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || `API Error: ${response.status}`);
                }
                const data = await response.json();
                return data.choices[0].message.content.trim();
                
            } else {
                const model = document.getElementById('anthropicModel').value;
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: model,
                        max_tokens: 8192,
                        messages: [{ role: 'user', content: prompt }]
                    })
                });
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || `API Error: ${response.status}`);
                }
                const data = await response.json();
                return data.content[0].text.trim();
            }
        }

        // ==================== DOCUMENT MODE ====================
        function handleFileSelect(event) {
            if (event.target.files.length) handleFile(event.target.files[0]);
        }

        async function handleFile(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (!['docx', 'epub', 'txt'].includes(ext)) {
                alert('Unsupported file format. Please use DOCX, EPUB, or TXT.');
                return;
            }

            currentFileName = file.name;
            currentFileType = ext;
            documentParagraphs = [];

            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileInfo').classList.remove('hidden');
            document.getElementById('fileStats').textContent = 'Loading...';

            try {
                if (ext === 'docx') {
                    await loadDocx(file);
                } else if (ext === 'epub') {
                    await loadEpub(file);
                } else {
                    await loadTxt(file);
                }

                const totalChars = documentParagraphs.reduce((sum, p) => sum + p.length, 0);
                
                // Check if we have a pending resume from a checkpoint
                if (window.pendingResume && window.pendingResume.fileName === file.name) {
                    const checkpoint = window.pendingResume;
                    const paragraphCount = checkpoint.paragraphCount || 0;
                    
                    // Verify paragraph count matches (roughly)
                    if (Math.abs(documentParagraphs.length - paragraphCount) <= 10) {
                        // Restore translated paragraphs from checkpoint
                        if (typeof checkpoint.translated === 'object' && !Array.isArray(checkpoint.translated)) {
                            translatedParagraphs = new Array(documentParagraphs.length).fill(null);
                            for (const [idx, text] of Object.entries(checkpoint.translated)) {
                                translatedParagraphs[parseInt(idx)] = text;
                            }
                        } else {
                            translatedParagraphs = checkpoint.translated || new Array(documentParagraphs.length).fill(null);
                        }
                        
                        const alreadyDone = Object.keys(checkpoint.translated || {}).length;
                        document.getElementById('fileStats').textContent = 
                            `${documentParagraphs.length} paragraphs ‚Ä¢ ${totalChars.toLocaleString()} characters ‚Ä¢ ${alreadyDone} already translated`;
                        
                        // Restore settings
                        if (checkpoint.targetLang) {
                            document.getElementById('targetLang').value = checkpoint.targetLang;
                        }
                        if (checkpoint.blankLines !== undefined) {
                            document.getElementById('blankLines').checked = checkpoint.blankLines;
                        }
                        
                        // Show resume info in log area
                        document.getElementById('progressSection').classList.remove('hidden');
                        logChunk(`üìÇ File loaded. Found ${alreadyDone} translated paragraphs from checkpoint.`);
                        logChunk(`‚ñ∂Ô∏è Click "Start Translation" to continue from paragraph ${checkpoint.completedCount}`);
                        
                        // Store the start index for when translation begins
                        window.resumeFromIndex = checkpoint.completedCount;
                        
                    } else {
                        // Paragraph count mismatch - might be different file
                        console.warn(`Paragraph count mismatch: checkpoint has ${paragraphCount}, file has ${documentParagraphs.length}`);
                        translatedParagraphs = new Array(documentParagraphs.length).fill(null);
                        document.getElementById('fileStats').textContent = 
                            `${documentParagraphs.length} paragraphs ‚Ä¢ ${totalChars.toLocaleString()} characters`;
                    }
                    
                    window.pendingResume = null; // Clear pending resume
                } else {
                    // Normal load - no pending resume
                    translatedParagraphs = new Array(documentParagraphs.length).fill(null);
                    document.getElementById('fileStats').textContent = 
                        `${documentParagraphs.length} paragraphs ‚Ä¢ ${totalChars.toLocaleString()} characters`;
                    window.resumeFromIndex = null;
                }
                
                updateCostEstimate(totalChars);
                document.getElementById('startTranslationBtn').disabled = false;

            } catch (error) {
                alert(`Error loading file: ${error.message}`);
                clearDocument();
            }
        }

        async function loadDocx(file) {
            const arrayBuffer = await file.arrayBuffer();
            
            // Store original for later reconstruction
            originalDocxZip = await JSZip.loadAsync(arrayBuffer);
            
            // Extract text with mammoth
            const result = await mammoth.extractRawText({ arrayBuffer });
            documentParagraphs = result.value.split('\n').filter(p => p.trim());
        }

        async function loadEpub(file) {
            const arrayBuffer = await file.arrayBuffer();
            originalEpubZip = await JSZip.loadAsync(arrayBuffer);
            epubTextNodes = [];
            documentParagraphs = [];
            
            // Find and process content files
            const htmlFiles = [];
            for (const [path, zipEntry] of Object.entries(originalEpubZip.files)) {
                if (path.endsWith('.xhtml') || path.endsWith('.html') || path.endsWith('.htm')) {
                    htmlFiles.push({ path, zipEntry });
                }
            }
            
            // Sort by path to ensure consistent ordering
            htmlFiles.sort((a, b) => a.path.localeCompare(b.path));
            
            for (const { path, zipEntry } of htmlFiles) {
                const content = await zipEntry.async('string');
                
                // Parse HTML - try XHTML first, fall back to HTML
                const parser = new DOMParser();
                let doc = parser.parseFromString(content, 'application/xhtml+xml');
                
                // Check for parse errors
                const parseError = doc.querySelector('parsererror');
                if (parseError) {
                    // Fallback to HTML parser
                    doc = parser.parseFromString(content, 'text/html');
                }
                
                // Walk through all text-containing elements
                const textElements = doc.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, figcaption');
                
                let nodeIndex = 0;
                for (const elem of textElements) {
                    const text = elem.textContent.trim();
                    
                    if (text && text.length > 0) {
                        // Store reference for later reconstruction
                        epubTextNodes.push({
                            filePath: path,
                            originalText: text,
                            nodeIndex: nodeIndex
                        });
                        documentParagraphs.push(text);
                        nodeIndex++;
                    }
                }
            }
            
            console.log(`EPUB loaded: ${documentParagraphs.length} paragraphs from ${htmlFiles.length} files`);
        }
        
        function getElementSelector(elem, index) {
            // Create a simple selector based on tag and position
            const tag = elem.tagName.toLowerCase();
            return `${tag}:nth-of-type-text(${index})`;
        }

        async function loadTxt(file) {
            const text = await file.text();
            // For TXT, use double line breaks as paragraph separators
            documentParagraphs = text.split(/\n\s*\n/).map(p => p.replace(/\n/g, ' ').trim()).filter(p => p);
        }

        function updateCostEstimate(chars) {
            let model;
            if (currentProvider === 'gemini') {
                model = document.getElementById('geminiModel').value;
            } else if (currentProvider === 'openai') {
                model = document.getElementById('openaiModel').value;
            } else {
                model = document.getElementById('anthropicModel').value;
            }
            
            // Rough cost estimates per 1M characters (input + output)
            const costs = {
                // Gemini
                'gemini-3-flash-preview': 0.15,
                'gemini-3-pro-preview': 2.50,
                'gemini-2.5-flash': 0.20,
                'gemini-2.5-pro': 3.50,
                // OpenAI
                'gpt-5-mini': 0.30,
                'gpt-5.1': 3.00,
                'gpt-5.2': 4.00,
                'gpt-4o-mini': 0.20,
                'gpt-4o': 3.00,
                'gpt-4.1': 3.50,
                // Claude
                'claude-haiku-4-5-20251001': 0.60,
                'claude-sonnet-4-5-20250929': 1.80,
                'claude-opus-4-5-20251124': 3.00,
                'claude-sonnet-4-20250514': 1.80,
                'claude-opus-4-20250514': 9.00
            };
            
            const costPer1M = costs[model] || 0.50;
            const estimated = (chars / 1000000) * costPer1M * 2; // *2 for input+output
            
            document.getElementById('costText').textContent = 
                `~$${estimated.toFixed(3)} (rough estimate)`;
        }

        function clearDocument() {
            documentParagraphs = [];
            translatedParagraphs = [];
            currentFileName = null;
            currentFileType = null;
            originalDocxZip = null;
            originalEpubZip = null;
            epubTextNodes = [];
            
            document.getElementById('fileInput').value = '';
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('progressSection').classList.add('hidden');
            document.getElementById('startTranslationBtn').disabled = true;
            document.getElementById('downloadBtn').classList.add('hidden');
        }

        async function startDocumentTranslation() {
            let apiKey;
            let providerName;
            
            if (currentProvider === 'gemini') {
                apiKey = geminiKeyInput.value.trim();
                providerName = 'Gemini';
            } else if (currentProvider === 'openai') {
                apiKey = openaiKeyInput.value.trim();
                providerName = 'OpenAI';
            } else {
                apiKey = anthropicKeyInput.value.trim();
                providerName = 'Claude';
            }
                
            if (!apiKey) {
                alert(`Please enter your ${providerName} API key!`);
                return;
            }

            if (documentParagraphs.length === 0) {
                alert('No document loaded!');
                return;
            }

            isTranslating = true;
            shouldStop = false;
            
            // Check if we're resuming from a checkpoint (after file re-upload)
            let startIndex = 0;
            if (window.resumeFromIndex !== null && window.resumeFromIndex !== undefined) {
                startIndex = window.resumeFromIndex;
                // Don't reset translatedParagraphs - they were restored from checkpoint
                logChunk(`‚ñ∂Ô∏è Resuming from paragraph ${startIndex} with ${providerName}`);
                window.resumeFromIndex = null; // Clear so next start is fresh
            } else {
                // Fresh start - reset translated paragraphs
                translatedParagraphs = new Array(documentParagraphs.length).fill(null);
            }

            document.getElementById('startTranslationBtn').classList.add('hidden');
            document.getElementById('stopTranslationBtn').classList.remove('hidden');
            document.getElementById('progressSection').classList.remove('hidden');
            if (startIndex === 0) {
                document.getElementById('chunkStatus').innerHTML = '';
            }

            await translateDocument(apiKey, startIndex);
        }

        async function translateDocument(apiKey, startIndex) {
            const total = documentParagraphs.length;
            const BATCH_SIZE = 10; // Translate 10 paragraphs per API call
            const MAX_CHARS_PER_BATCH = 8000; // Max characters per batch to stay within token limits
            
            let i = startIndex;
            let batchCount = 0;
            
            while (i < total) {
                if (shouldStop) {
                    logChunk(`‚èπ Stopped at paragraph ${i + 1}/${total}`);
                    break;
                }

                // Build a batch of paragraphs
                let batch = [];
                let batchChars = 0;
                let batchStartIndex = i;
                
                while (i < total && batch.length < BATCH_SIZE && batchChars < MAX_CHARS_PER_BATCH) {
                    const paragraph = documentParagraphs[i];
                    if (paragraph.trim()) {
                        batch.push({ index: i, text: paragraph });
                        batchChars += paragraph.length;
                    } else {
                        // Empty paragraph, mark as done
                        translatedParagraphs[i] = '';
                    }
                    i++;
                }
                
                if (batch.length === 0) continue;
                
                batchCount++;
                const batchEnd = i;
                updateProgress(i, total, `Translating batch ${batchCount} (paragraphs ${batchStartIndex + 1}-${batchEnd})...`);
                logChunk(`‚Üí Batch ${batchCount}: paragraphs ${batchStartIndex + 1}-${batchEnd} (${batch.length} items, ${batchChars} chars)`);

                try {
                    // Combine paragraphs with markers for splitting later
                    const SEPARATOR = '\n\n===PARAGRAPH_BREAK===\n\n';
                    const combinedText = batch.map(b => b.text).join(SEPARATOR);
                    
                    const translated = await translateTextBatch(combinedText, SEPARATOR, apiKey);
                    const translatedParts = translated.split(/===PARAGRAPH_BREAK===/i).map(s => s.trim());
                    
                    // Map back to original indices
                    for (let j = 0; j < batch.length; j++) {
                        const originalIndex = batch[j].index;
                        translatedParagraphs[originalIndex] = translatedParts[j] || batch[j].text;
                    }
                    
                    logChunk(`‚úì Batch ${batchCount} done (${batch.length} paragraphs)`);
                } catch (error) {
                    logChunk(`‚úó Batch ${batchCount} error: ${error.message}`);
                    
                    // Check for content filter errors
                    const isContentFilter = error.message.toLowerCase().includes('safety') || 
                                           error.message.toLowerCase().includes('blocked') ||
                                           error.message.toLowerCase().includes('harmful') ||
                                           error.message.toLowerCase().includes('policy');
                    
                    if (isContentFilter) {
                        logChunk(`‚ö†Ô∏è Content filter triggered - trying individual paragraphs`);
                    }
                    
                    // Fallback: translate individually
                    logChunk(`‚ü≥ Falling back to individual translation...`);
                    for (const item of batch) {
                        if (shouldStop) break;
                        try {
                            await sleep(1000);
                            const translated = await translateText(item.text, apiKey);
                            translatedParagraphs[item.index] = translated;
                            logChunk(`  ‚úì Paragraph ${item.index + 1} done`);
                        } catch (retryError) {
                            const errMsg = retryError.message || 'Unknown error';
                            const isFilterError = errMsg.toLowerCase().includes('safety') || 
                                                 errMsg.toLowerCase().includes('blocked') ||
                                                 errMsg.toLowerCase().includes('harmful') ||
                                                 errMsg.toLowerCase().includes('policy') ||
                                                 errMsg.toLowerCase().includes('recitation');
                            
                            if (isFilterError) {
                                translatedParagraphs[item.index] = `[CONTENT FILTER - keeping original]\n\n${item.text}`;
                                logChunk(`  ‚ö†Ô∏è Paragraph ${item.index + 1}: Content filter (${errMsg.substring(0, 50)})`);
                            } else {
                                translatedParagraphs[item.index] = `[ERROR: ${errMsg}]\n\nOriginal:\n${item.text}`;
                                logChunk(`  ‚úó Paragraph ${item.index + 1} failed: ${errMsg.substring(0, 80)}`);
                            }
                        }
                    }
                }

                // Save checkpoint every batch
                saveCheckpoint(i);

                // Shorter delay between batches (rate limit aware)
                await sleep(200);
            }

            isTranslating = false;
            
            if (!shouldStop) {
                updateProgress(total, total, 'Translation complete!');
                clearCheckpoint();
                document.getElementById('downloadBtn').classList.remove('hidden');
            }
            
            document.getElementById('stopTranslationBtn').classList.add('hidden');
            document.getElementById('startTranslationBtn').classList.remove('hidden');
        }

        function stopDocumentTranslation() {
            shouldStop = true;
            document.getElementById('stopTranslationBtn').textContent = 'Stopping...';
            document.getElementById('stopTranslationBtn').disabled = true;
            
            setTimeout(() => {
                document.getElementById('stopTranslationBtn').textContent = 'Stop';
                document.getElementById('stopTranslationBtn').disabled = false;
            }, 2000);
        }

        function updateProgress(current, total, text) {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressText').textContent = text;
            document.getElementById('progressPercent').textContent = `${percent}%`;
            document.getElementById('progressBar').style.width = `${percent}%`;
        }

        function logChunk(message) {
            const status = document.getElementById('chunkStatus');
            const time = new Date().toLocaleTimeString();
            status.innerHTML = `[${time}] ${message}\n` + status.innerHTML;
        }

        // ==================== CHECKPOINT SYSTEM ====================
        function saveCheckpoint(completedCount) {
            // Only save non-null translated paragraphs to reduce size
            const translatedCompact = {};
            for (let i = 0; i < translatedParagraphs.length; i++) {
                if (translatedParagraphs[i] !== null) {
                    translatedCompact[i] = translatedParagraphs[i];
                }
            }
            
            const checkpoint = {
                fileName: currentFileName,
                fileType: currentFileType,
                paragraphCount: documentParagraphs.length,
                // Store original paragraphs only if small enough, otherwise skip
                paragraphs: documentParagraphs.length <= 500 ? documentParagraphs : null,
                translated: translatedCompact,
                completedCount: completedCount,
                provider: currentProvider,
                targetLang: document.getElementById('targetLang').value,
                blankLines: document.getElementById('blankLines').checked,
                timestamp: Date.now()
            };
            
            try {
                const jsonString = JSON.stringify(checkpoint);
                const sizeKB = Math.round(jsonString.length / 1024);
                
                // Check size before saving (localStorage limit is ~5-10MB)
                if (jsonString.length > 4 * 1024 * 1024) {
                    logChunk(`‚ö†Ô∏è Checkpoint too large (${sizeKB} KB), saving without original text`);
                    // Save without original paragraphs
                    checkpoint.paragraphs = null;
                    localStorage.setItem('translationCheckpoint', JSON.stringify(checkpoint));
                } else {
                    localStorage.setItem('translationCheckpoint', jsonString);
                }
                logChunk(`üíæ Checkpoint saved (${completedCount}/${documentParagraphs.length}) [${sizeKB} KB]`);
            } catch (e) {
                logChunk(`‚ö†Ô∏è Checkpoint save failed: ${e.message}`);
                // Try saving minimal checkpoint
                try {
                    const minimalCheckpoint = {
                        fileName: currentFileName,
                        fileType: currentFileType,
                        paragraphCount: documentParagraphs.length,
                        paragraphs: null,
                        translated: translatedCompact,
                        completedCount: completedCount,
                        provider: currentProvider,
                        targetLang: document.getElementById('targetLang').value,
                        blankLines: document.getElementById('blankLines').checked,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('translationCheckpoint', JSON.stringify(minimalCheckpoint));
                    logChunk(`üíæ Minimal checkpoint saved (${completedCount}/${documentParagraphs.length})`);
                } catch (e2) {
                    logChunk(`‚ùå Could not save checkpoint: ${e2.message}`);
                }
            }
        }

        function clearCheckpoint() {
            localStorage.removeItem('translationCheckpoint');
        }

        function checkForCheckpoint() {
            const saved = localStorage.getItem('translationCheckpoint');
            if (!saved) return;

            try {
                const checkpoint = JSON.parse(saved);
                
                // Check if checkpoint is less than 24 hours old
                if (Date.now() - checkpoint.timestamp > 24 * 60 * 60 * 1000) {
                    clearCheckpoint();
                    return;
                }

                const paragraphCount = checkpoint.paragraphCount || checkpoint.paragraphs?.length || 0;
                document.getElementById('resumeInfo').textContent = 
                    `File: ${checkpoint.fileName} ‚Ä¢ ${checkpoint.completedCount}/${paragraphCount} paragraphs completed`;
                
                // Show original provider info
                const providerNames = { gemini: 'Gemini', openai: 'OpenAI', anthropic: 'Claude' };
                const originalProvider = providerNames[checkpoint.provider] || checkpoint.provider;
                document.getElementById('resumeProviderInfo').textContent = 
                    `Started with: ${originalProvider} ‚Ä¢ You can switch providers above before resuming`;
                
                document.getElementById('resumePrompt').classList.remove('hidden');
                
                // Switch to document mode
                selectMode('document');
            } catch (e) {
                clearCheckpoint();
            }
        }

        function resumeTranslation() {
            const saved = localStorage.getItem('translationCheckpoint');
            if (!saved) return;

            try {
                const checkpoint = JSON.parse(saved);
                
                currentFileName = checkpoint.fileName;
                currentFileType = checkpoint.fileType;
                
                // Handle new compact format
                const paragraphCount = checkpoint.paragraphCount || checkpoint.paragraphs?.length || 0;
                
                if (checkpoint.paragraphs) {
                    // Old format or small document: paragraphs were saved
                    documentParagraphs = checkpoint.paragraphs;
                } else {
                    // New format: paragraphs not saved, need to re-upload file
                    alert('The original document was too large to save in the checkpoint. Please upload the file again, and the existing translations will be preserved.');
                    document.getElementById('resumePrompt').classList.add('hidden');
                    
                    // Still restore the translated paragraphs for when file is re-uploaded
                    if (typeof checkpoint.translated === 'object' && !Array.isArray(checkpoint.translated)) {
                        // New compact format: object with indices as keys
                        translatedParagraphs = new Array(paragraphCount).fill(null);
                        for (const [idx, text] of Object.entries(checkpoint.translated)) {
                            translatedParagraphs[parseInt(idx)] = text;
                        }
                    } else {
                        translatedParagraphs = checkpoint.translated || [];
                    }
                    
                    // Store checkpoint info for when file is re-uploaded
                    window.pendingResume = checkpoint;
                    return;
                }
                
                // Restore translated paragraphs
                if (typeof checkpoint.translated === 'object' && !Array.isArray(checkpoint.translated)) {
                    // New compact format: object with indices as keys
                    translatedParagraphs = new Array(documentParagraphs.length).fill(null);
                    for (const [idx, text] of Object.entries(checkpoint.translated)) {
                        translatedParagraphs[parseInt(idx)] = text;
                    }
                } else {
                    // Old format: array
                    translatedParagraphs = checkpoint.translated || new Array(documentParagraphs.length).fill(null);
                }
                
                document.getElementById('fileName').textContent = checkpoint.fileName;
                document.getElementById('fileInfo').classList.remove('hidden');
                
                // Show info about provider switch if different
                const providerNames = { gemini: 'Gemini', openai: 'OpenAI', anthropic: 'Claude' };
                let statusText = `${documentParagraphs.length} paragraphs ‚Ä¢ Resuming from ${checkpoint.completedCount}`;
                if (checkpoint.provider !== currentProvider) {
                    statusText += ` ‚Ä¢ Switching from ${providerNames[checkpoint.provider]} to ${providerNames[currentProvider]}`;
                }
                document.getElementById('fileStats').textContent = statusText;
                
                document.getElementById('resumePrompt').classList.add('hidden');
                document.getElementById('targetLang').value = checkpoint.targetLang;
                if (checkpoint.blankLines !== undefined) {
                    document.getElementById('blankLines').checked = checkpoint.blankLines;
                }
                
                // DON'T switch provider - use the currently selected one!
                // This allows users to switch providers mid-translation (e.g., if rate limited)
                // selectProvider(checkpoint.provider);  // REMOVED
                
                // Use the currently selected provider's API key
                let apiKey;
                let providerName;
                if (currentProvider === 'gemini') {
                    apiKey = geminiKeyInput.value.trim();
                    providerName = 'Gemini';
                } else if (currentProvider === 'openai') {
                    apiKey = openaiKeyInput.value.trim();
                    providerName = 'OpenAI';
                } else {
                    apiKey = anthropicKeyInput.value.trim();
                    providerName = 'Claude';
                }
                    
                if (!apiKey) {
                    alert(`Please enter your ${providerName} API key first, then click Resume again.`);
                    document.getElementById('startTranslationBtn').disabled = false;
                    return;
                }

                isTranslating = true;
                shouldStop = false;
                
                document.getElementById('startTranslationBtn').classList.add('hidden');
                document.getElementById('stopTranslationBtn').classList.remove('hidden');
                document.getElementById('progressSection').classList.remove('hidden');
                
                logChunk(`‚ñ∂Ô∏è Resuming with ${providerName} from paragraph ${checkpoint.completedCount}`);
                
                translateDocument(apiKey, checkpoint.completedCount);
                
            } catch (e) {
                alert('Error resuming: ' + e.message);
                clearCheckpoint();
            }
        }

        function discardCheckpoint() {
            clearCheckpoint();
            document.getElementById('resumePrompt').classList.add('hidden');
        }

        // ==================== DOWNLOAD ====================
        async function downloadTranslation() {
            const baseName = currentFileName.replace(/\.[^.]+$/, '');
            const targetLang = document.getElementById('targetLang').value;
            
            // Filter out null entries and prepare paragraphs
            const paragraphs = translatedParagraphs.filter(p => p !== null);
            
            if (currentFileType === 'txt') {
                // TXT input ‚Üí TXT output
                downloadAsTxt(paragraphs, baseName, targetLang);
            } else if (currentFileType === 'epub' && originalEpubZip && epubTextNodes.length > 0) {
                // EPUB input ‚Üí EPUB output with preserved formatting
                await downloadAsEpub(baseName, targetLang);
            } else {
                // DOCX input ‚Üí DOCX output
                await downloadAsDocx(paragraphs, baseName, targetLang);
            }
        }
        
        async function downloadAsEpub(baseName, targetLang) {
            // Clone the original EPUB
            const newZip = new JSZip();
            
            // Copy all files from original
            for (const [path, zipEntry] of Object.entries(originalEpubZip.files)) {
                if (zipEntry.dir) {
                    newZip.folder(path);
                } else {
                    const content = await zipEntry.async('arraybuffer');
                    newZip.file(path, content);
                }
            }
            
            // Group text nodes by file
            const nodesByFile = {};
            epubTextNodes.forEach((node, index) => {
                if (!nodesByFile[node.filePath]) {
                    nodesByFile[node.filePath] = [];
                }
                nodesByFile[node.filePath].push({
                    ...node,
                    translatedText: translatedParagraphs[index] || node.originalText
                });
            });
            
            // Process each HTML file
            for (const [filePath, nodes] of Object.entries(nodesByFile)) {
                const originalContent = await originalEpubZip.file(filePath).async('string');
                const translatedContent = replaceTextInHtml(originalContent, nodes);
                newZip.file(filePath, translatedContent);
            }
            
            // Generate and download
            const blob = await newZip.generateAsync({ 
                type: 'blob',
                mimeType: 'application/epub+zip',
                compression: 'DEFLATE'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}_${targetLang}.epub`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function replaceTextInHtml(htmlContent, nodes) {
            // Parse the HTML
            const parser = new DOMParser();
            let doc = parser.parseFromString(htmlContent, 'application/xhtml+xml');
            
            // Check for parse errors, fall back to HTML
            const parseError = doc.querySelector('parsererror');
            if (parseError) {
                doc = parser.parseFromString(htmlContent, 'text/html');
            }
            
            // Find all text-containing elements
            const textElements = doc.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, td, th, blockquote, figcaption');
            
            let nodeIndex = 0;
            for (const elem of textElements) {
                const text = elem.textContent.trim();
                if (text && text.length > 0) {
                    // Find matching node
                    const matchingNode = nodes.find(n => n.nodeIndex === nodeIndex);
                    if (matchingNode && matchingNode.translatedText) {
                        // Replace text content while preserving child element structure
                        replaceTextContent(elem, matchingNode.originalText, matchingNode.translatedText);
                    }
                    nodeIndex++;
                }
            }
            
            // Serialize back to string
            const serializer = new XMLSerializer();
            return serializer.serializeToString(doc);
        }
        
        function replaceTextContent(element, originalText, translatedText) {
            // If element has no child elements, simply replace text
            if (element.children.length === 0) {
                element.textContent = translatedText;
                return;
            }
            
            // For elements with mixed content (text + child elements like <em>, <strong>),
            // we need to be more careful. For now, replace all text content.
            // This may lose some inline formatting, but preserves block structure.
            
            // Simple approach: if the text content matches, replace it
            const currentText = element.textContent.trim();
            if (currentText === originalText.trim()) {
                // Walk through child nodes and replace text nodes
                const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
                const textNodes = [];
                let node;
                while (node = walker.nextNode()) {
                    if (node.textContent.trim()) {
                        textNodes.push(node);
                    }
                }
                
                if (textNodes.length === 1) {
                    // Single text node - easy replacement
                    textNodes[0].textContent = translatedText;
                } else if (textNodes.length > 1) {
                    // Multiple text nodes - put all translated text in first, clear others
                    textNodes[0].textContent = translatedText;
                    for (let i = 1; i < textNodes.length; i++) {
                        textNodes[i].textContent = '';
                    }
                }
            }
        }
        
        function downloadAsTxt(paragraphs, baseName, targetLang) {
            const text = paragraphs.join('\n\n');
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}_${targetLang}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        async function downloadAsDocx(paragraphs, baseName, targetLang) {
            const { Document, Packer, Paragraph, TextRun } = docx;
            
            // Create document with paragraphs
            const docParagraphs = paragraphs.map(text => {
                // Check if this is an error/original text block
                if (text.startsWith('[CONTENT FILTER') || text.startsWith('[ERROR:')) {
                    return new Paragraph({
                        children: [
                            new TextRun({
                                text: text,
                                color: 'FF0000',  // Red for errors
                                italics: true
                            })
                        ],
                        spacing: { after: 200 }
                    });
                }
                
                return new Paragraph({
                    children: [new TextRun(text)],
                    spacing: { after: 200 }  // Add spacing between paragraphs
                });
            });
            
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: docParagraphs
                }]
            });
            
            // Generate and download
            const blob = await Packer.toBlob(doc);
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${baseName}_${targetLang}.docx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ==================== TRANSLATION API ====================
        async function translateText(text, apiKey) {
            if (currentProvider === 'gemini') {
                return await translateWithGemini(text, apiKey);
            } else if (currentProvider === 'openai') {
                return await translateWithOpenAI(text, apiKey);
            } else {
                return await translateWithAnthropic(text, apiKey);
            }
        }

        async function translateTextBatch(text, separator, apiKey) {
            if (currentProvider === 'gemini') {
                return await translateWithGeminiBatch(text, separator, apiKey);
            } else if (currentProvider === 'openai') {
                return await translateWithOpenAIBatch(text, separator, apiKey);
            } else {
                return await translateWithAnthropicBatch(text, separator, apiKey);
            }
        }

        function getTranslationPrompt(text) {
            const targetLang = document.getElementById('targetLang').value;
            const style = document.getElementById('styleHint').value;
            
            const langNames = {
                'de': 'German', 'en': 'English', 'fr': 'French', 'es': 'Spanish',
                'it': 'Italian', 'la': 'Latin', 'el': 'Modern Greek', 'grc': 'Ancient Greek'
            };
            
            const styleInstructions = {
                'academic': 'Maintain an academic, scholarly tone. Preserve technical terminology.',
                'neutral': 'Use a neutral, clear tone suitable for general readers.',
                'simple': 'Use simple, accessible language. Avoid jargon.',
                'literal': 'Translate as literally as possible while remaining grammatically correct.'
            };

            return `Translate the following text to ${langNames[targetLang]}. 
${styleInstructions[style]}
Preserve paragraph breaks.
Output only the translation, no explanations or preamble.

Text to translate:
${text}`;
        }

        async function translateWithGemini(text, apiKey) {
            const model = document.getElementById('geminiModel').value;
            const prompt = getTranslationPrompt(text);

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 8192
                        }
                    })
                }
            );

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `API Error: ${response.status}`);
            }

            const data = await response.json();
            
            // Check for content filter / safety block
            if (!data.candidates || data.candidates.length === 0) {
                const blockReason = data.promptFeedback?.blockReason || 'Unknown';
                const safetyRatings = data.promptFeedback?.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ') || '';
                throw new Error(`Content blocked (${blockReason}). Safety: ${safetyRatings}`);
            }
            
            const candidate = data.candidates[0];
            
            // Check if candidate was blocked
            if (candidate.finishReason === 'SAFETY' || candidate.finishReason === 'RECITATION') {
                const safetyRatings = candidate.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ') || '';
                throw new Error(`Response blocked (${candidate.finishReason}). Safety: ${safetyRatings}`);
            }
            
            if (!candidate.content?.parts?.[0]?.text) {
                throw new Error(`Empty response. Finish reason: ${candidate.finishReason || 'unknown'}`);
            }
            
            let result = candidate.content.parts[0].text;
            // Apply paragraph formatting based on user preference
            const useBlankLines = document.getElementById('blankLines').checked;
            if (useBlankLines) {
                result = result.replace(/\n{3,}/g, '\n\n').trim();
            } else {
                result = result.replace(/\n{2,}/g, '\n').trim();
            }
            return result;
        }

        async function translateWithOpenAI(text, apiKey) {
            const model = document.getElementById('openaiModel').value;
            const prompt = getTranslationPrompt(text);

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: [
                        {
                            role: 'system',
                            content: 'You are a professional translator specializing in academic and historical texts. Translate accurately while maintaining readability.'
                        },
                        { role: 'user', content: prompt }
                    ],
                    temperature: 0.3,
                    max_tokens: 8192
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `API Error: ${response.status}`);
            }

            const data = await response.json();
            let result = data.choices[0].message.content;
            // Apply paragraph formatting based on user preference
            const useBlankLines = document.getElementById('blankLines').checked;
            if (useBlankLines) {
                result = result.replace(/\n{3,}/g, '\n\n').trim();
            } else {
                result = result.replace(/\n{2,}/g, '\n').trim();
            }
            return result;
        }

        // Batch translation functions for document mode
        function getBatchTranslationPrompt(text, separator) {
            const targetLang = document.getElementById('targetLang').value;
            const style = document.getElementById('styleHint').value;
            
            const langNames = {
                'de': 'German', 'en': 'English', 'fr': 'French', 'es': 'Spanish',
                'it': 'Italian', 'la': 'Latin', 'el': 'Modern Greek', 'grc': 'Ancient Greek'
            };
            
            const styleInstructions = {
                'academic': 'Maintain an academic, scholarly tone. Preserve technical terminology.',
                'neutral': 'Use a neutral, clear tone suitable for general readers.',
                'simple': 'Use simple, accessible language. Avoid jargon.',
                'literal': 'Translate as literally as possible while remaining grammatically correct.'
            };

            return `Translate the following paragraphs to ${langNames[targetLang]}. 
${styleInstructions[style]}

IMPORTANT: The text contains multiple paragraphs separated by "===PARAGRAPH_BREAK===". 
Keep these exact markers in your translation to separate the translated paragraphs.
Output only the translation with the markers, no explanations or preamble.

Text to translate:
${text}`;
        }

        async function translateWithGeminiBatch(text, separator, apiKey) {
            const model = document.getElementById('geminiModel').value;
            const prompt = getBatchTranslationPrompt(text, separator);

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 16384
                        }
                    })
                }
            );

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `API Error: ${response.status}`);
            }

            const data = await response.json();
            
            // Check for content filter / safety block
            if (!data.candidates || data.candidates.length === 0) {
                const blockReason = data.promptFeedback?.blockReason || 'Unknown';
                throw new Error(`Content blocked (${blockReason})`);
            }
            
            const candidate = data.candidates[0];
            if (candidate.finishReason === 'SAFETY' || candidate.finishReason === 'RECITATION') {
                throw new Error(`Response blocked (${candidate.finishReason})`);
            }
            
            if (!candidate.content?.parts?.[0]?.text) {
                throw new Error(`Empty response. Finish reason: ${candidate.finishReason || 'unknown'}`);
            }
            
            let result = candidate.content.parts[0].text;
            const useBlankLines = document.getElementById('blankLines').checked;
            if (useBlankLines) {
                result = result.replace(/\n{3,}/g, '\n\n').trim();
            } else {
                result = result.replace(/\n{2,}/g, '\n').trim();
            }
            return result;
        }

        async function translateWithOpenAIBatch(text, separator, apiKey) {
            const model = document.getElementById('openaiModel').value;
            const prompt = getBatchTranslationPrompt(text, separator);

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: [
                        {
                            role: 'system',
                            content: 'You are a professional translator. Translate the paragraphs while preserving the ===PARAGRAPH_BREAK=== markers exactly as they appear.'
                        },
                        { role: 'user', content: prompt }
                    ],
                    temperature: 0.3,
                    max_tokens: 16384
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `API Error: ${response.status}`);
            }

            const data = await response.json();
            let result = data.choices[0].message.content;
            const useBlankLines = document.getElementById('blankLines').checked;
            if (useBlankLines) {
                result = result.replace(/\n{3,}/g, '\n\n').trim();
            } else {
                result = result.replace(/\n{2,}/g, '\n').trim();
            }
            return result;
        }

        // Anthropic/Claude API functions
        async function translateWithAnthropic(text, apiKey) {
            const model = document.getElementById('anthropicModel').value;
            const prompt = getTranslationPrompt(text);

            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: model,
                    max_tokens: 8192,
                    messages: [
                        { role: 'user', content: prompt }
                    ]
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `API Error: ${response.status}`);
            }

            const data = await response.json();
            
            if (!data.content || data.content.length === 0) {
                throw new Error('Empty response from Claude');
            }
            
            let result = data.content[0].text;
            const useBlankLines = document.getElementById('blankLines').checked;
            if (useBlankLines) {
                result = result.replace(/\n{3,}/g, '\n\n').trim();
            } else {
                result = result.replace(/\n{2,}/g, '\n').trim();
            }
            return result;
        }

        async function translateWithAnthropicBatch(text, separator, apiKey) {
            const model = document.getElementById('anthropicModel').value;
            const prompt = getBatchTranslationPrompt(text, separator);

            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: model,
                    max_tokens: 16384,
                    messages: [
                        { role: 'user', content: prompt }
                    ]
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error?.message || `API Error: ${response.status}`);
            }

            const data = await response.json();
            
            if (!data.content || data.content.length === 0) {
                throw new Error('Empty response from Claude');
            }
            
            let result = data.content[0].text;
            const useBlankLines = document.getElementById('blankLines').checked;
            if (useBlankLines) {
                result = result.replace(/\n{3,}/g, '\n\n').trim();
            } else {
                result = result.replace(/\n{2,}/g, '\n').trim();
            }
            return result;
        }

        // ==================== HISTORY ====================
        const HISTORY_MAX_PASSAGE = 20;
        const HISTORY_MAX_PROOFREAD = 20;
        const HISTORY_PREVIEW_LENGTH = 80;
        let currentHistoryMode = 'passage';

        function getHistoryKey(mode) {
            return `translator_history_${mode}`;
        }

        function loadHistory(mode) {
            try {
                const data = localStorage.getItem(getHistoryKey(mode));
                return data ? JSON.parse(data) : [];
            } catch (e) {
                console.error('Error loading history:', e);
                return [];
            }
        }

        function saveHistory(mode, history) {
            try {
                localStorage.setItem(getHistoryKey(mode), JSON.stringify(history));
            } catch (e) {
                console.error('Error saving history:', e);
                // If storage is full, remove oldest entries and retry
                if (history.length > 5) {
                    history = history.slice(0, Math.floor(history.length / 2));
                    try {
                        localStorage.setItem(getHistoryKey(mode), JSON.stringify(history));
                    } catch (e2) {
                        console.error('Still cannot save history:', e2);
                    }
                }
            }
        }

        function addToHistory(mode, input, output, meta = {}) {
            const history = loadHistory(mode);
            const maxItems = mode === 'passage' ? HISTORY_MAX_PASSAGE : HISTORY_MAX_PROOFREAD;
            
            const entry = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                input: input,
                output: output,
                provider: currentProvider,
                ...meta
            };
            
            // Add to beginning
            history.unshift(entry);
            
            // Trim to max
            if (history.length > maxItems) {
                history.length = maxItems;
            }
            
            saveHistory(mode, history);
        }

        function openHistory(mode) {
            currentHistoryMode = mode;
            const history = loadHistory(mode);
            const modal = document.getElementById('historyModal');
            const list = document.getElementById('historyList');
            const title = document.getElementById('historyTitle');
            const footer = document.getElementById('historyFooter');
            
            title.textContent = mode === 'passage' ? 'Translation History' : 'Proofread History';
            
            if (history.length === 0) {
                list.innerHTML = '<div class="p-8 text-center text-gray-400">No history yet</div>';
                footer.textContent = '';
            } else {
                list.innerHTML = history.map((entry, index) => {
                    const date = new Date(entry.timestamp);
                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    const preview = entry.input.substring(0, HISTORY_PREVIEW_LENGTH) + (entry.input.length > HISTORY_PREVIEW_LENGTH ? '...' : '');
                    const langInfo = entry.targetLang ? ` ‚Üí ${entry.targetLang.toUpperCase()}` : '';
                    const levelInfo = entry.level ? ` (${entry.level})` : '';
                    
                    return `
                        <div class="history-item" onclick="restoreHistory(${index})">
                            <div class="history-item-preview">${escapeHtml(preview)}</div>
                            <div class="history-item-meta">
                                ${dateStr} ‚Ä¢ ${entry.provider}${langInfo}${levelInfo}
                                <button onclick="event.stopPropagation(); deleteHistoryItem(${index})" 
                                    class="ml-2 text-red-400 hover:text-red-600">‚úï</button>
                            </div>
                        </div>
                    `;
                }).join('');
                footer.textContent = `${history.length} entries ‚Ä¢ Click to restore`;
            }
            
            modal.classList.add('open');
        }

        function closeHistoryModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('historyModal').classList.remove('open');
        }

        function restoreHistory(index) {
            const history = loadHistory(currentHistoryMode);
            const entry = history[index];
            if (!entry) return;
            
            if (currentHistoryMode === 'passage') {
                document.getElementById('passageInput').value = entry.input;
                document.getElementById('passageOutput').value = entry.output;
                if (entry.targetLang) {
                    document.getElementById('targetLang').value = entry.targetLang;
                }
                selectMode('passage');
            } else {
                document.getElementById('proofreadInput').value = entry.input;
                document.getElementById('proofreadOutput').value = entry.output;
                if (entry.textLang) {
                    document.getElementById('proofreadLang').value = entry.textLang;
                }
                if (entry.level) {
                    const radio = document.querySelector(`input[name="proofreadLevel"][value="${entry.level}"]`);
                    if (radio) radio.checked = true;
                }
                selectMode('proofread');
            }
            
            closeHistoryModal();
        }

        function deleteHistoryItem(index) {
            const history = loadHistory(currentHistoryMode);
            history.splice(index, 1);
            saveHistory(currentHistoryMode, history);
            openHistory(currentHistoryMode); // Refresh display
        }

        function clearHistory() {
            if (!confirm(`Delete all ${currentHistoryMode} history?`)) return;
            localStorage.removeItem(getHistoryKey(currentHistoryMode));
            openHistory(currentHistoryMode); // Refresh display
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==================== UTILITIES ====================
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
